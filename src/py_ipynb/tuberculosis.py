# -*- coding: utf-8 -*-
"""Tuberculosis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LuytHH1rMyi-ko9LzdT4PHoIbVNB4siw
"""

import os
import re
import pandas as pd

#Loading the images from the filepath.
image_folder = '/content/drive/MyDrive/Projects /colab et al/TB_CXR_images'
csv_file = 'labels.csv'

#This is a list of the images which have been identified as TB positive we will place them in a python list.

image_files = '''MCUCXR_0104_1.png
MCUCXR_0108_1.png
MCUCXR_0108_1.png
MCUCXR_0108_1.png
MCUCXR_0108_1.png
MCUCXR_0113_1.png
MCUCXR_0113_1.png
MCUCXR_0113_1.png
MCUCXR_0117_1.png
MCUCXR_0126_1.png
MCUCXR_0126_1.png
MCUCXR_0141_1.png
MCUCXR_0142_1.png
MCUCXR_0144_1.png
MCUCXR_0150_1.png
MCUCXR_0150_1.png
MCUCXR_0150_1.png
MCUCXR_0150_1.png
MCUCXR_0162_1.png
MCUCXR_0162_1.png
MCUCXR_0166_1.png
MCUCXR_0166_1.png
MCUCXR_0166_1.png
MCUCXR_0170_1.png
MCUCXR_0170_1.png
MCUCXR_0170_1.png
MCUCXR_0170_1.png
MCUCXR_0170_1.png
MCUCXR_0173_1.png
MCUCXR_0173_1.png
MCUCXR_0182_1.png
MCUCXR_0182_1.png
MCUCXR_0188_1.png
MCUCXR_0188_1.png
MCUCXR_0188_1.png
MCUCXR_0194_1.png
MCUCXR_0196_1.png
MCUCXR_0196_1.png
MCUCXR_0203_1.png
MCUCXR_0203_1.png
MCUCXR_0213_1.png
MCUCXR_0218_1.png
MCUCXR_0223_1.png
MCUCXR_0228_1.png
MCUCXR_0228_1.png
MCUCXR_0228_1.png
MCUCXR_0228_1.png
MCUCXR_0243_1.png
MCUCXR_0251_1.png
MCUCXR_0251_1.png
MCUCXR_0251_1.png
MCUCXR_0251_1.png
MCUCXR_0253_1.png
MCUCXR_0254_1.png
MCUCXR_0255_1.png
MCUCXR_0258_1.png
MCUCXR_0258_1.png
MCUCXR_0258_1.png
MCUCXR_0264_1.png
MCUCXR_0266_1.png
MCUCXR_0275_1.png
MCUCXR_0275_1.png
MCUCXR_0282_1.png
MCUCXR_0282_1.png
MCUCXR_0282_1.png
MCUCXR_0289_1.png
MCUCXR_0294_1.png
MCUCXR_0301_1.png
MCUCXR_0301_1.png
MCUCXR_0309_1.png
MCUCXR_0309_1.png
MCUCXR_0309_1.png
MCUCXR_0311_1.png
MCUCXR_0311_1.png
MCUCXR_0311_1.png
MCUCXR_0311_1.png
MCUCXR_0311_1.png
MCUCXR_0313_1.png
MCUCXR_0313_1.png
MCUCXR_0316_1.png
MCUCXR_0316_1.png
MCUCXR_0316_1.png
MCUCXR_0331_1.png
MCUCXR_0334_1.png
MCUCXR_0338_1.png
MCUCXR_0348_1.png
MCUCXR_0348_1.png
MCUCXR_0348_1.png
MCUCXR_0348_1.png
MCUCXR_0350_1.png
MCUCXR_0352_1.png
MCUCXR_0354_1.png
MCUCXR_0354_1.png
MCUCXR_0362_1.png
MCUCXR_0362_1.png
MCUCXR_0367_1.png
MCUCXR_0367_1.png
MCUCXR_0369_1.png
MCUCXR_0369_1.png
MCUCXR_0372_1.png
MCUCXR_0375_1.png
MCUCXR_0375_1.png
MCUCXR_0387_1.png
MCUCXR_0387_1.png
MCUCXR_0390_1.png
MCUCXR_0393_1.png
MCUCXR_0393_1.png
MCUCXR_0399_1.png
MCUCXR_0399_1.png'''

# Paths to the TB image list and image directory
tb_image_list = image_files.split()

# Path to the image directory
image_dir = "/content/drive/MyDrive/Projects /colab et al/TB_CXR_images"

# Regex pattern to identify TB images (adjust if needed)
tb_image_pattern = r"^MCUCXR_\d{4}_1\.png$"  # Matches names like "MCUCXR_1234_1.png"

# Create empty lists for filenames and labels
filenames = []
labels = []

# Iterate through each image in the directory
for filename in os.listdir(image_dir):
    full_path = os.path.join(image_dir, filename)

    # Check if the filename matches the TB image pattern
    if re.match(tb_image_pattern, filename):
        labels.append(1)  # TB positive
    else:
        labels.append(0)  # TB negative

    filenames.append(filename)

df = pd.DataFrame({'filename': filenames, 'label': labels})

df.to_csv('labels.csv', index=False)

df.tail()

import torch
from torchvision import datasets, transforms
from PIL import Image
from torch.utils.data import Dataset, DataLoader
import pandas as pd

class CustomImageDataset(Dataset):
    def __init__(self, dataframe, root_dir, transform=None):
        self.dataframe = dataframe
        self.root_dir = root_dir
        self.transform = transform

    def __len__(self):
        return len(self.dataframe)

    def __getitem__(self, idx):
        img_name = os.path.join(self.root_dir, self.dataframe.iloc[idx, 0])
        image = Image.open(img_name).convert('RGB')
        label = torch.tensor(int(self.dataframe.iloc[idx, 1]))

        if self.transform:
            image = self.transform(image)

        return image, label

# Define data transformations (will adjust as needed)
data_transform = transforms.Compose([
    transforms.Resize((224, 224)),  # Resize here
    transforms.ToTensor(),
])

# Creating an instance of CustomImageDataset
custom_dataset = CustomImageDataset(dataframe=df, root_dir=image_dir, transform=data_transform)

# Spliting dataset into training and testing sets
train_size = int(0.8 * len(custom_dataset))
test_size = len(custom_dataset) - train_size
train_dataset, test_dataset = torch.utils.data.random_split(custom_dataset, [train_size, test_size])

# Defining data loaders
train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)

import torch
import torch.nn as nn

# A simple CNN model
class SimpleCNN(nn.Module):
    def __init__(self):
        super(SimpleCNN, self).__init__()
        self.conv1 = nn.Conv2d(3, 16, kernel_size=3, stride=1, padding=1)
        self.conv2 = nn.Conv2d(16, 32, kernel_size=3, stride=1, padding=1)
        self.pool = nn.MaxPool2d(2, 2)
        self.fc1 = nn.Linear(32 * 56 * 56, 128)
        self.fc2 = nn.Linear(128, 2)  # 2 output classes (TB positive and negative)

    def forward(self, x):
        x = self.pool(torch.relu(self.conv1(x)))
        x = self.pool(torch.relu(self.conv2(x)))
        x = x.view(-1, 32 * 56 * 56)
        x = torch.relu(self.fc1(x))
        x = self.fc2(x)
        return x

# Instantiating the model
model = SimpleCNN()

import torch.optim as optim

# Define loss function and optimizer
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

num_epochs = 10

for epoch in range(num_epochs):
    model.train()
    running_loss = 0.0
    for i, data in enumerate(train_loader, 0):
        inputs, labels = data
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        running_loss += loss.item()

    print(f"Epoch {epoch + 1}/{num_epochs}, Loss: {running_loss / len(train_loader)}")

model.eval()
correct = 0
total = 0
with torch.no_grad():
    for data in test_loader:
        images, labels = data
        outputs = model(images)
        _, predicted = torch.max(outputs.data, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

accuracy = 100 * correct / total
print(f"Accuracy on test set: {accuracy:.2f}%")

